
namespace CmdLine:


//@section consts

const MAX {
	Index COLS = 80;
	Index ROWS = 25;
}


//@section defs

enum Bit4 Colors {
	Black = 0,
	Blue = 1,
	Green = 2,
	Cyan = 3,
	Red = 4,
	Magenta = 5,
	Brown = 6,
	LightGrey = 7,
	DarkGrey = 8,
	LightBlue = 9,
	LightGreen = 10,
	LightCyan = 11,
	LightRed = 12,
	LightMagenta = 13,
	LightBrown = 14,
	White = 15,
};

struct Byte2 ScreenChar @packed {
	Color color;
	Char char;
}


//@section vars

Current {
	Index row;
	Index col;
	Color color;
}

volatile Byte2 Pointer buffer;

Byte2 ioPort; // base IO port for video (VGA), usually 0x3D4
Cursor {
	Byte startRegister {
		@bits {
			@5 cursorDisable;
		}
	}
}

//@section

function Init() { //@entry

	Current.color = LightGrey, DarkGrey;
	ioPort = valueof 0x0463; // @TODO always at 0x0463?

	OutB(ioPort, 0x0A); // Cursor Start Register
	Cursor.startRegister = InB(ioPort + 1);

	Current.row = 0;
	Current.col = 0;

	// @TODO monochrome monitors at 0xB0000?
	// @TODO video address const
	// @TODO is it always 0xB8000?
	buffer = 0xB8000; // VGA text mode 3 video buffer address
}

// @TODO:
function EntryPut_Terminal_VGA(char character, Byte color, Index x, Index y) {
	const Index index = y * COLS_MAX_VGA + x;
	buffer[index] = EntryMake_VGA(character, color);
}

function NewLine_Terminal_VGA() {
	colCurrentTerminal_VGA = 0;
	if (++rowCurrentTerminal_VGA == ROWS_MAX_VGA) {
		rowCurrentTerminal_VGA = 0;
		// TODO scroll screen
	}

	// clear line
	for (Index i = 0; i < COLS_MAX_VGA; i++) {
		EntryPut_Terminal_VGA(0, colorCurrentTerminal_VGA, i, rowCurrentTerminal_VGA);
	}
}

function Backspace_Terminal_VGA() {
	colCurrentTerminal_VGA--;
	EntryPut_Terminal_VGA(0, colorCurrentTerminal_VGA, colCurrentTerminal_VGA, rowCurrentTerminal_VGA);
}

function PutChar_Terminal_VGA(char character) {
	if (character == '\n') {
		NewLine_Terminal_VGA();
	} else {
		EntryPut_Terminal_VGA(character, colorCurrentTerminal_VGA, colCurrentTerminal_VGA, rowCurrentTerminal_VGA);
		colCurrentTerminal_VGA++;
		if (colCurrentTerminal_VGA == COLS_MAX_VGA) {
			NewLine_Terminal_VGA();
		}
	}
}


// Echo("Foo");
// Echo("String: %s", "foo");
// Echo("String: %s%", "foo", "\nAnd another: %s", "bar");
function Echo(const char* text, ...) {

	char** args = (char **)&text;
	char* arg = *args;

	char c;

	while ((c = *arg++) != 0) {
		if (c == '%') {
			c = *arg++;
			char* tmp;

			switch (c) {
				case '%':
					PutChar_Terminal_VGA(c);
					break;

				case 'i': // signed int
				case 'u': // unsigned int
				case 'x': // hex
				case 'b': // binary
				{
					char buffer[17];
					args++;
					Number2String(*(int*)args, buffer, c);
					tmp = buffer;
					goto echoString;
				}
				break;

				case 's':
					args++;
					tmp = *args;

				echoString:
					while (*tmp)
						PutChar_Terminal_VGA(*tmp++);
					break;
			}
			tmp = arg;
			if (*tmp++ == '%' && *tmp == 0) { // go to next string
				args++;
				arg = *args;
			}

		} else {
			PutChar_Terminal_VGA(c);
		}
	}
}

function SetPositionToCursor() {
	Byte2 pos;

	OutB(ioPort, 0x0e);
	pos = InB(ioPort + 1) << 8;
	OutB(ioPort, 0x0f);
	pos |= InB(ioPort + 1);
	
	Current.row = pos % MAX.COLS;
	Current.col = pos / MAX.COLS;
}

Cursor {
	function SetPosition(Index row, Index col) {
		unsigned short position = (row * 80) + col;

		// cursor LOW port to vga INDEX register
		OutB(ioPort, 0x0F);
		OutB(ioPort + 1, (Byte)(position & 0xFF));
		// cursor HIGH port to vga INDEX register
		OutB(ioPort, 0x0E);
		OutB(ioPort + 1, (Byte)((position >> 8) & 0xFF));
	}

	function SetToCurrentPosition() {
		SetPosition(Current.row, Current.col);
	}

	function Enable() {

		cursorStartRegister.bits.cursorDisable = 0;
		
		OutB(ioPort, 0x0A);
		OutB(ioPort + 1, cursorStartRegister);
	}

	function Disable() {

		cursorStartRegister.bits.cursorDisable = 1;

		OutB(ioPort, 0x0A);
		OutB(ioPort + 1, cursorStartRegister);
	}
}